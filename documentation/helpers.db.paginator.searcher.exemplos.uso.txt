/*
LIB db.js + paginator.js + searcher.js
--------------------------------------

Conexão e execução de queries no MS SQL Server através do pacote NODE mssql

=> exemplos de parâmetros JSON de entrada para queries:
*/

// ---------------------------------------------------------------------------------------------------------
// Estrutura básica queries (parâmetros de entrada)

query = {
	formato: 1, // 1: Query String, 2: Stored Procedure
	dados: {
		input: [
			['ID', 'int', 1],
			['NOME', 'varchar(200)', '%Nome Exemplo 1%']
		],
		output: [
			['QTD_RET', 'int']
		],
		executar: `
			SELECT * FROM TABELA T (NOLOCK) WHERE T.ID_TABELA=@ID OR T.NOME LIKE(@NOME);
			SET @QTD_RET = SCOPE_IDENTITY();
		`
	}
}

query = {
	formato: 2, // 1: Query String, 2: Stored Procedure
	dados: {
		input: [
			['ID', 'int', 1],
			['NOME', 'varchar(200)', 'Nome Exemplo 2']
		],
		output: [
			['QTD_RET', 'int']
		],
		executar: 'USUARIO_CONSULTAR'
	}
}

/* * input pode utilizar também um formato de chamada com apenas dois parâmetros de entrada, omitindo o tipo do dado * */

// ---------------------------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------------------------
// Parâmetros de entrada (exemplos)

let query = {
		formato: 1,
		dados: {
			input: [
				['NOME', 'varchar(200)', 'Joaquim Santos'],
				['SENHA', 'varchar(20)', 'SENH@TESTE123'],
				['ATIVO', 'bit', 1],
				['NOMECHECK', '%Joa%']
			],
			output: [
				['INSERTED_ID', 'int']
			],
			executar: `
				SET NOCOUNT OFF;
				DECLARE
					@INCR int; -- variavel interna
				SET
					@INCR = (
						SELECT TOP 1
							ID_USUARIO
						FROM
							USUARIO U (NOLOCK)
						WHERE
							U.NOME LIKE(@NOMECHECK) -- variavel input externa
						ORDER BY
							ID_USUARIO DESC
					);
				INSERT INTO USUARIO (
					NOME
					,SENHA
					,ATIVO
				) VALUES (
					@NOME + ' ' + CAST(@INCR AS varchar) -- variavel input externa + interna
					,@SENHA -- variavel input externa
					,@ATIVO -- variavel input externa
				);
				SET
					@INSERTED_ID = SCOPE_IDENTITY(); -- variavel output
				SELECT TOP 2
					NOME
				FROM
					USUARIO U (NOLOCK)
				WHERE
					U.NOME LIKE(@NOMECHECK) -- variavel input externa
				ORDER BY
					ID_USUARIO DESC;
				SELECT TOP 3
					*
				FROM
					USUARIO U (NOLOCK)
				WHERE
					U.NOME LIKE(@NOMECHECK) -- variavel input externa
				ORDER BY
					ID_USUARIO DESC;
			`
		}
	},
	otherQuery = {
		formato: 2,
		dados: {
			input: [
				['ID_USUARIO', 'int', 1],
				['NOME', 'varchar(200)', 'joa']
			],
			output: [
				['QTD_RET', 'int']
			],
			executar: 'USUARIO_CONSULTAR'
		}
	},
	anotherQuery = {
		formato: 1,
		dados: {
			input: [
				['NOME', '%joa%']
			],
			executar: 'SELECT ID_USUARIO, NOME, SENHA, ATIVO FROM USUARIO (NOLOCK) WHERE NOME LIKE(@NOME)'
		}
	};
// ---------------------------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------------------------
// Chamadas nos métodos (exemplos)

// Execute (promise + async await)
const dbCon = require('@serverRoot/helpers/db');

dbCon.msSqlServer.sqlOpenCon()
.then(
	async transaction => {
		try {
			let query = {
					formato: 1,
					dados: {
						input: [
							['NOME', '%joa%']
						],
						executar: 'SELECT ID_USUARIO, NOME, SENHA, ATIVO FROM USUARIO (NOLOCK) WHERE NOME LIKE(@NOME)'
					}
				};

			let resultSet = await dbCon.msSqlServer.sqlExecute(transaction, query); // Executa query ou queries
			await dbCon.msSqlServer.sqlCloseCon(transaction);

			resolve(resultSet);
		} catch(err) {
			reject(err);
		}
	}
)
.catch(
	err => {
		reject(err);
	}
);

// Execute (async await)
const dbCon = require('@serverRoot/helpers/db');

try {
	let query = {
			formato: 1,
			dados: {
				input: [
					['NOME', '%joa%']
				],
				executar: 'SELECT ID_USUARIO, NOME, SENHA, ATIVO FROM USUARIO (NOLOCK) WHERE NOME LIKE(@NOME)'
			}
		};

	let transaction = await dbCon.msSqlServer.sqlOpenCon(),
		resultSet = await dbCon.msSqlServer.sqlExecute(transaction, query); // Executa query ou queries
	await dbCon.msSqlServer.sqlCloseCon(transaction);

	return resultSet;
} catch(err) {
	throw Error(err);
}

// ou com o método agrupador ExecuteAll (async await)
const dbCon = require('@serverRoot/helpers/db');

try {
	let query = {
			formato: 1,
			dados: {
				input: [
					['NOME', '%joa%']
				],
				executar: 'SELECT ID_USUARIO, NOME, SENHA, ATIVO FROM USUARIO (NOLOCK) WHERE NOME LIKE(@NOME)'
			}
		};

	// Executa query ou queries
	let resultSet = await dbCon.msSqlServer.sqlExecuteAll(query);

	return resultSet;
} catch(err) {
	throw Error(err);
}
// ---------------------------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------------------------
// Chamada com PAGINAÇÃO
const dbCon = require('@serverRoot/helpers/db');
const paginator = require('@serverRoot/helpers/paginator');

try {
	let query = {
			formato: 1,
			dados: {
				input: [
					['NOME', '%joa%']
				],
				executar: 'SELECT ID_USUARIO, NOME, SENHA, ATIVO FROM USUARIO (NOLOCK) WHERE NOME LIKE(@NOME)'
			}
		};

	// Executa query ou queries
	let resultSet = await dbCon.msSqlServer.sqlExecuteAll(query);
	// Paginador (page)
	resultSet.recordsets[0] = await paginator.setPage(req, resultSet.recordsets[0], resultSet.rowsAffected[0], true);

	return resultSet;
} catch(err) {
	throw Error(err);
}
// ---------------------------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------------------------
// Chamada com PAGINAÇÃO e ORDENAÇÃO
const dbCon = require('@serverRoot/helpers/db');
const paginator = require('@serverRoot/helpers/paginator');

try {
	let query = {
			formato: 1,
			dados: {
				input: [
					['NOME', '%joa%']
				],
				executar: 'SELECT ID_USUARIO, NOME, SENHA, ATIVO FROM USUARIO (NOLOCK) WHERE NOME LIKE(@NOME)'
			}
		};

	// Executa query ou queries
	let resultSet = await dbCon.msSqlServer.sqlExecuteAll(query);
	// Ordenador (sort)
	resultSet.recordsets[0] = await paginator.setSort(req, resultSet.recordsets[0], true);
	// Paginador (page)
	resultSet.recordsets[0] = await paginator.setPage(req, resultSet.recordsets[0], resultSet.rowsAffected[0]);

	return resultSet;
} catch(err) {
	throw Error(err);
}

/* * Apenas UM toCamelCase é necessário em todas as chamadas * */
/*
   * se toCamelCase = true no setSort, utilizar camelcase exato (case sensitive) para identificar as chaves de sort no banco de dados *
   * se toCamelCase = false no setSort, utilizar nome da coluna exato (case sensitive) para identificar as chaves de sort no banco de dados *
*/

// ---------------------------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------------------------
// Chamada com SEARCHER
const searcher = require('@serverRoot/helpers/searcher');

try {
	let replaceQuery = '{{REPLACE}}',
		baseQuery = `
			select top 10
				*
			from
				usuario a (nolock)
				inner join tipo b (nolock)
					on (a.id_tipo = b.id_tipo)
			where
				a.nome like('%joa%')
				${replaceQuery}
		`;

	// Searcher: searchFields deve ser uma array (colunas inválidas para pesquisa geram erro)
	let resultSet = await searcher.setSearch(
			req,
			baseQuery,
			replaceQuery
		);

	return resultSet;
} catch(err) {
	throw Error(err);
}

/* * REPLACE (via http GET) é case insensitive e pode ser enviado em SNAKE_CASE (padrão do banco deve ser SNAKE_CASE) ou camelCase * */

// ---------------------------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------------------------
// Chamada com SEARCHER (apenas para CamelCase)
const searcher = require('@serverRoot/helpers/searcher');
const paginator = require('@serverRoot/helpers/paginator');

try {
	let replaceQuery = '{{REPLACE}}',
		baseQuery = `
			select top 10
				*
			from
				usuario a (nolock)
				inner join tipo b (nolock)
					on (a.id_tipo = b.id_tipo)
			where
				a.nome like('%joa%')
				${replaceQuery}
		`;

	// Searcher: searchFields deve ser uma array (colunas inválidas para pesquisa geram erro)
	let resultSet = await searcher.setSearch(
			req,
			baseQuery,
			replaceQuery
		);

	resultSet.recordsets[0] = await paginator.keysToCamelCase(resultSet.recordsets[0]);

	return resultSet;
} catch(err) {
	throw Error(err);
}

/* * REPLACE (via http GET) é case insensitive e pode ser enviado em SNAKE_CASE (padrão do banco deve ser SNAKE_CASE) ou camelCase * */

// ---------------------------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------------------------
// Chamada com SEARCHER, PAGINACAO e ORDENAÇÃO
const searcher = require('@serverRoot/helpers/searcher');
const paginator = require('@serverRoot/helpers/paginator');

try {
	let replaceQuery = '{{REPLACE}}',
		baseQuery = `
			select top 10
				*
			from
				usuario a (nolock)
				inner join tipo b (nolock)
					on (a.id_tipo = b.id_tipo)
			where
				a.nome like('%joa%')
				${replaceQuery}
		`;

	// Searcher: searchFields deve ser uma array (colunas inválidas para pesquisa geram erro)
	let resultSet = await searcher.setSearch(
			req,
			baseQuery,
			replaceQuery
		);

	// Ordenador (sort)
	resultSet.recordsets[0] = await paginator.setSort(req, resultSet.recordsets[0], true);
	// Paginador (page)
	resultSet.recordsets[0] = await paginator.setPage(req, resultSet.recordsets[0], resultSet.rowsAffected[0]);

	return resultSet;
} catch(err) {
	throw Error(err);
}

/* * REPLACE (via http GET) é case insensitive e pode ser enviado em SNAKE_CASE (padrão do banco deve ser SNAKE_CASE) ou camelCase * */

/* * Apenas UM toCamelCase é necessário em todas as chamadas * */

/*
   * se toCamelCase = true no setSort, utilizar camelcase exato (case sensitive) para identificar as chaves de sort no banco de dados *
   * se toCamelCase = false no setSort, utilizar nome da coluna exato (case sensitive) para identificar as chaves de sort no banco de dados *
*/

// ---------------------------------------------------------------------------------------------------------
