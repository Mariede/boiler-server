/*
LIB db.js + paginator.js + searcher.js
--------------------------------------

Conexão e execução de queries no MS SQL Server através do pacote NODE mssql

=> exemplos de parâmetros JSON de entrada para queries:
*/

// ---------------------------------------------------------------------------------------------------------
// Estrutura básica queries (parâmetros de entrada)


query = {
	formato: 1, // 1: Query String, 2: Stored Procedure
	dados: {
		input: [
			['ID', 'int', 1],
			['NOME', 'varchar(200)', '%Nome Exemplo 1%']
		],
		output: [
			['QTD_RET', 'int']
		],
		executar: `
			SELECT * FROM TABELA T (NOLOCK) WHERE T.ID_TABELA=@ID OR T.NOME LIKE(@NOME);
			SET @QTD_RET = SCOPE_IDENTITY();
		`
	}
}


query = {
	formato: 2, // 1: Query String, 2: Stored Procedure
	dados: {
		input: [
			['ID', 'int', 1],
			['NOME', 'varchar(200)', 'Nome Exemplo 2']
		],
		output: [
			['QTD_RET', 'int']
		],
		executar: 'USUARIO_CONSULTAR'
	}
}

/* * input pode utilizar também um formato de chamada com apenas dois parâmetros de entrada, omitindo o tipo de dado * */
// ---------------------------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------------------------
// Parâmetros de entrada (exemplos)


let query = {
		formato: 1,
		dados: {
			input: [
				['NOME', 'varchar(200)', 'Joaquim Santos'],
				['SENHA', 'varchar(20)', 'SENH@TESTE123'],
				['ATIVO', 'bit', 1],
				['NOMECHECK', '%Joa%']
			],
			output: [
				['INSERTED_ID', 'int']
			],
			executar: `
				SET NOCOUNT OFF;
				DECLARE
					@INCR int; -- variavel interna
				SET
					@INCR = (
						SELECT TOP 1
							ID_USUARIO
						FROM
							USUARIO U (NOLOCK)
						WHERE
							U.NOME LIKE(@NOMECHECK) -- variavel input externa
						ORDER BY
							ID_USUARIO DESC
					);
				INSERT INTO USUARIO (
					NOME
					,SENHA
					,ATIVO
				) VALUES (
					@NOME + ' ' + CAST(@INCR AS varchar) -- variavel input externa + interna
					,@SENHA -- variavel input externa
					,@ATIVO -- variavel input externa
				);
				SET
					@INSERTED_ID = SCOPE_IDENTITY(); -- variavel output
				SELECT TOP 2
					NOME
				FROM
					USUARIO U (NOLOCK)
				WHERE
					U.NOME LIKE(@NOMECHECK) -- variavel input externa
				ORDER BY
					ID_USUARIO DESC;
				SELECT TOP 3
					*
				FROM
					USUARIO U (NOLOCK)
				WHERE
					U.NOME LIKE(@NOMECHECK) -- variavel input externa
				ORDER BY
					ID_USUARIO DESC;
			`
		}
	},
	otherQuery = {
		formato: 2,
		dados: {
			input: [
				['ID_USUARIO', 'int', 1],
				['NOME', 'varchar(200)', 'joa']
			],
			output: [
				['QTD_RET', 'int']
			],
			executar: 'USUARIO_CONSULTAR'
		}
	},
	anotherQuery = {
		formato: 1,
		dados: {
			input: [
				['NOME', '%joa%']
			],
			executar: 'SELECT SORTER2, SORTER1, ID_USUARIO, NOME, SENHA, ATIVO FROM USUARIO (NOLOCK) WHERE NOME LIKE(@NOME)'
		}
	};
// ---------------------------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------------------------
// Chamadas nos métodos (exemplos)


// Execute (promise + async await)
const dbCon = require('@serverRoot/helpers/db');

dbCon.sqlOpenCon()
.then(
	async transaction => {
		try {
			let query = {
					formato: 1,
					dados: {
						input: [
							['NOME', '%joa%']
						],
						executar: 'SELECT SORTER2, SORTER1, ID_USUARIO, NOME, SENHA, ATIVO FROM USUARIO (NOLOCK) WHERE NOME LIKE(@NOME)'
					}
				};

			let resultSet = await dbCon.sqlExecute(transaction, query); // Executa query ou queries
			await dbCon.sqlCloseCon(transaction);

			resolve(resultSet);
		} catch(err) {
			reject(err);
		}
	}
)
.catch(
	err => {
		reject(err);
	}
);


// Execute (async await)
const dbCon = require('@serverRoot/helpers/db');

try {
	let query = {
			formato: 1,
			dados: {
				input: [
					['NOME', '%joa%']
				],
				executar: 'SELECT SORTER2, SORTER1, ID_USUARIO, NOME, SENHA, ATIVO FROM USUARIO (NOLOCK) WHERE NOME LIKE(@NOME)'
			}
		};

	let transaction = await dbCon.sqlOpenCon(),
		resultSet = await dbCon.sqlExecute(transaction, query); // Executa query ou queries
	await dbCon.sqlCloseCon(transaction);

	return resultSet;
} catch(err) {
	throw Error(err);
}


// ou com o método agrupador ExecuteAll (async await)
const dbCon = require('@serverRoot/helpers/db');

try {
	let query = {
			formato: 1,
			dados: {
				input: [
					['NOME', '%joa%']
				],
				executar: 'SELECT SORTER2, SORTER1, ID_USUARIO, NOME, SENHA, ATIVO FROM USUARIO (NOLOCK) WHERE NOME LIKE(@NOME)'
			}
		};

	// Executa query ou queries
	let resultSet = await dbCon.sqlExecuteAll(query);

	return resultSet;
} catch(err) {
	throw Error(err);
}
// ---------------------------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------------------------
// Chamada com paginação
const dbCon = require('@serverRoot/helpers/db');
const paginator = require('@serverRoot/helpers/paginator');

try {
	let query = {
			formato: 1,
			dados: {
				input: [
					['NOME', '%joa%']
				],
				executar: 'SELECT SORTER2, SORTER1, ID_USUARIO, NOME, SENHA, ATIVO FROM USUARIO (NOLOCK) WHERE NOME LIKE(@NOME)'
			}
		};

	// Executa query ou queries
	let resultSet = await dbCon.sqlExecuteAll(query);
	// Paginador (page)
	resultSet.recordsets[0] = await paginator.setPage(req, resultSet.recordsets[0], resultSet.rowsAffected[0]);

	return resultSet;
} catch(err) {
	throw Error(err);
}
// ---------------------------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------------------------
// Chamada com paginação e ordenação
const dbCon = require('@serverRoot/helpers/db');
const paginator = require('@serverRoot/helpers/paginator');

try {
	let query = {
			formato: 1,
			dados: {
				input: [
					['NOME', '%joa%']
				],
				executar: 'SELECT SORTER2, SORTER1, ID_USUARIO, NOME, SENHA, ATIVO FROM USUARIO (NOLOCK) WHERE NOME LIKE(@NOME)'
			}
		};

	// Executa query ou queries
	let resultSet = await dbCon.sqlExecuteAll(query);
	// Ordenador (sort)
	resultSet.recordsets[0] = await paginator.setSort(req, resultSet.recordsets[0]);
	// Paginador (page)
	resultSet.recordsets[0] = await paginator.setPage(req, resultSet.recordsets[0], resultSet.rowsAffected[0]);

	return resultSet;
} catch(err) {
	throw Error(err);
}

/* * neste caso, utilizar nome exato (case sensitive) em setSort para identificar as chaves de sort no banco de dados * */
// ---------------------------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------------------------
// Chamada com paginação, ordenação e conversão para camelcase do json do banco de dados
const dbCon = require('@serverRoot/helpers/db');
const paginator = require('@serverRoot/helpers/paginator');

try {
	let query = {
			formato: 1,
			dados: {
				input: [
					['NOME', '%joa%']
				],
				executar: 'SELECT SORTER2, SORTER1, ID_USUARIO, NOME, SENHA, ATIVO FROM USUARIO (NOLOCK) WHERE NOME LIKE(@NOME)'
			}
		};

	// Executa query ou queries
	let resultSet = await dbCon.sqlExecuteAll(query);
	// Camel Case: renomeia chaves no objeto JSON para o padrao Camel Case
	resultSet.recordsets[0] = await paginator.keysToCamelCase(resultSet.recordsets[0]);
	// Ordenador (sort)
	resultSet.recordsets[0] = await paginator.setSort(req, resultSet.recordsets[0]);
	// Paginador (page)
	resultSet.recordsets[0] = await paginator.setPage(req, resultSet.recordsets[0], resultSet.rowsAffected[0]);

	return resultSet;
} catch(err) {
	throw Error(err);
}

/* * se keysToCamelCase for chamado antes de setSort, utilizar camelcase para identificar as chaves de sort no banco de dados * */
// ---------------------------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------------------------
// Chamada com searcher
const searcher = require('@serverRoot/helpers/searcher');

try {
	let replaceQuery = '{{REPLACE}}',
		baseQuery = `
			select top 10
				*
			from
				usuario a (nolock)
				inner join tipo b (nolock)
					on (a.id_tipo = b.id_tipo)
			where
				a.nome like('%joa%')
				${replaceQuery}
		`;

	// Searcher: searchFields deve ser uma array (nomes ambiguos no search geram erro)
	let resultSet = await searcher.setSearch(
			req,
			baseQuery,
			replaceQuery
		);

	return resultSet;
} catch(err) {
	throw Error(err);
}
// ---------------------------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------------------------
// Chamada com searcher, paginação, ordenação e conversão para camelcase do json do banco de dados
const searcher = require('@serverRoot/helpers/searcher');
const paginator = require('@serverRoot/helpers/paginator');

try {
	let replaceQuery = '{{REPLACE}}',
		baseQuery = `
			select top 10
				*
			from
				usuario a (nolock)
				inner join tipo b (nolock)
					on (a.id_tipo = b.id_tipo)
			where
				a.nome like('%joa%')
				${replaceQuery}
		`;

	// Searcher: searchFields deve ser uma array (nomes ambiguos no search geram erro)
	let resultSet = await searcher.setSearch(
			req,
			baseQuery,
			replaceQuery
		);

	// Camel Case: renomeia chaves no objeto JSON para o padrao Camel Case
	resultSet.recordsets[0] = await paginator.keysToCamelCase(resultSet.recordsets[0]);
	// Ordenador (sort)
	resultSet.recordsets[0] = await paginator.setSort(req, resultSet.recordsets[0]);
	// Paginador (page)
	resultSet.recordsets[0] = await paginator.setPage(req, resultSet.recordsets[0], resultSet.rowsAffected[0]);

	return resultSet;
} catch(err) {
	throw Error(err);
}
// ---------------------------------------------------------------------------------------------------------
