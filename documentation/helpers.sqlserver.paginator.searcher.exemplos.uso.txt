LIB db.js (SQL Server) + paginator.js + searcher.js
===================================================

Conexão e execução de queries no MS SQL Server através do pacote NODE mssql



// ---------------------------------------------------------------------------------------------------------
// Recordsets - padrão de retorno:

Não paginado:
{
	"recordset": [],
	"output": {},
	"rowsAffected": [
		0
	]
}

Paginado (default):
{
	"pageDetails": {
		"currentPage": 1,
		"itemsPerPage": 10,
		"itemsFrom": 0,
		"itemsTo": 0,
		"itemsCount": 0,
		"totalPages": 0
	},
	"recordset": [],
	"output": {},
	"rowsAffected": [
		0
	]
}

// ---------------------------------------------------------------------------------------------------------
// Estrutura básica queries (parâmetros de entrada)

query = {
	formato: 1, // 1: Query String, 2: Stored Procedure
	dados: {
		input: [
			['ID', 'int', 1],
			['NOME', 'varchar(200)', '%Nome Exemplo 1%']
		],
		output: [
			['QTD_RET', 'int']
		],
		executar: `
			SELECT * FROM TABELA T (NOLOCK) WHERE T.ID_TABELA=@ID OR T.NOME LIKE(@NOME);
			SET @QTD_RET = SCOPE_IDENTITY();
		`
	}
}

query = {
	formato: 2, // 1: Query String, 2: Stored Procedure
	dados: {
		input: [
			['ID', 'int', 1],
			['NOME', 'varchar(200)', 'Nome Exemplo 2']
		],
		output: [
			['QTD_RET', 'int']
		],
		executar: 'USUARIO_CONSULTAR'
	}
}

/* * input pode utilizar também um formato de chamada com apenas dois parâmetros de entrada, omitindo o tipo do dado * */

// ---------------------------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------------------------
// Parâmetros de entrada (exemplos)

let query = {
		formato: 1,
		dados: {
			input: [
				['NOME', 'varchar(200)', 'Joaquim Santos'],
				['SENHA', 'varchar(20)', 'SENH@TESTE123'],
				['ATIVO', 'bit', 1],
				['NOMECHECK', '%Jo%']
			],
			output: [
				['INSERTED_ID', 'int']
			],
			executar: `
				SET NOCOUNT OFF;
				DECLARE
					@INCR int; -- variavel interna
				SET
					@INCR = (
						SELECT TOP 1
							ID_USUARIO
						FROM
							USUARIO U (NOLOCK)
						WHERE
							U.NOME LIKE(@NOMECHECK) -- variavel input externa
						ORDER BY
							ID_USUARIO DESC
					);
				INSERT INTO USUARIO (
					NOME
					,SENHA
					,ATIVO
				) VALUES (
					@NOME + ' ' + CAST(@INCR AS varchar) -- variavel input externa + interna
					,@SENHA -- variavel input externa
					,@ATIVO -- variavel input externa
				);
				SET
					@INSERTED_ID = SCOPE_IDENTITY(); -- variavel output
				SELECT TOP 2
					NOME
				FROM
					USUARIO U (NOLOCK)
				WHERE
					U.NOME LIKE(@NOMECHECK) -- variavel input externa
				ORDER BY
					ID_USUARIO DESC;
				SELECT TOP 3
					*
				FROM
					USUARIO U (NOLOCK)
				WHERE
					U.NOME LIKE(@NOMECHECK) -- variavel input externa
				ORDER BY
					ID_USUARIO DESC;
			`
		}
	},
	otherQuery = {
		formato: 2,
		dados: {
			input: [
				['ID_USUARIO', 'int', 1],
				['NOME', 'varchar(200)', 'jo']
			],
			output: [
				['QTD_RET', 'int']
			],
			executar: 'USUARIO_CONSULTAR'
		}
	},
	anotherQuery = {
		formato: 1,
		dados: {
			input: [
				['NOME', '%jo%']
			],
			executar: 'SELECT ID_USUARIO, NOME, SENHA, ATIVO FROM USUARIO (NOLOCK) WHERE NOME LIKE(@NOME)'
		}
	};
// ---------------------------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------------------------
// Chamadas nos métodos (exemplos)

// Execute (async await)
const dbCon = require('@serverRoot/helpers/db');

try {
	const query = {
		formato: 1,
		dados: {
			input: [
				['NOME', '%jo%']
			],
			executar: 'SELECT ID_USUARIO, NOME, SENHA, ATIVO FROM USUARIO (NOLOCK) WHERE NOME LIKE(@NOME)'
		}
	};

	let transaction = await dbCon.msSqlServer.sqlOpenCon(),
		{ recordsets: recordSets, ...resultSet } = await dbCon.msSqlServer.sqlExecute(transaction, query); // Executa query ou queries

	await dbCon.msSqlServer.sqlCloseCon(transaction);

	return resultSet;
} catch(err) {
	throw Error(err);
}

// ou com o método agrupador ExecuteAll (async await)
const dbCon = require('@serverRoot/helpers/db');

try {
	const query = {
		formato: 1,
		dados: {
			input: [
				['NOME', '%jo%']
			],
			executar: 'SELECT ID_USUARIO, NOME, SENHA, ATIVO FROM USUARIO (NOLOCK) WHERE NOME LIKE(@NOME)'
		}
	};

	// Executa query ou queries
	let { recordsets: recordSets, ...resultSet } = await dbCon.msSqlServer.sqlExecuteAll(query);

	return resultSet;
} catch(err) {
	throw Error(err);
}
// ---------------------------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------------------------
// Chamada com PAGINAÇÃO
const dbCon = require('@serverRoot/helpers/db');
const paginator = require('@serverRoot/helpers/paginator');

try {
	const query = {
		formato: 1,
		dados: {
			input: [
				['NOME', '%jo%']
			],
			executar: 'SELECT ID_USUARIO, NOME, SENHA, ATIVO FROM USUARIO (NOLOCK) WHERE NOME LIKE(@NOME)'
		}
	};

	// Executa query ou queries
	let { recordsets: recordSets, ...resultSet } = await dbCon.msSqlServer.sqlExecuteAll(query);

	// Paginador (page)
	resultSet = await paginator.setPage(req, resultSet, resultSet.rowsAffected[0], true);

	return resultSet;
} catch(err) {
	throw Error(err);
}
// ---------------------------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------------------------
// Chamada com PAGINAÇÃO e ORDENAÇÃO
const dbCon = require('@serverRoot/helpers/db');
const paginator = require('@serverRoot/helpers/paginator');

try {
	const query = {
		formato: 1,
		dados: {
			input: [
				['NOME', '%jo%']
			],
			executar: 'SELECT ID_USUARIO, NOME, SENHA, ATIVO FROM USUARIO (NOLOCK) WHERE NOME LIKE(@NOME)'
		}
	};

	// Executa query ou queries
	let { recordsets: recordSets, ...resultSet } = await dbCon.msSqlServer.sqlExecuteAll(query);

	// Ordenador (sort)
	resultSet.recordset = await paginator.setSort(req, resultSet.recordset, true);
	// Paginador (page)
	resultSet = await paginator.setPage(req, resultSet, resultSet.rowsAffected[0]);

	return resultSet;
} catch(err) {
	throw Error(err);
}

/* * Apenas UM toCamelCase é necessário em todas as chamadas * */

/*
   * se toCamelCase = true no setSort, utilizar camelCase exato (case sensitive) para identificar as chaves de sort no Json *
   * se toCamelCase = false no setSort, utilizar nome da coluna exato no banco de dados (case sensitive) para identificar as chaves de sort no Json *
*/

// ---------------------------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------------------------
// Chamada com SEARCHER
const searcher = require('@serverRoot/helpers/searcher');

try {
	const replaceQuery = '{{REPLACE}}';
	const baseQuery = `
		select top 10
			*
		from
			usuario a (nolock)
			inner join tipo b (nolock)
				on (a.id_tipo = b.id_tipo)
		where
			a.nome like('%jo%')
			${replaceQuery}
	`;

	// Searcher: searchFields deve ser uma array (colunas inválidas para pesquisa geram erro)
	let { recordsets: recordSets, ...resultSet } = await searcher.setSearch(
		req,
		baseQuery,
		replaceQuery
	);

	return resultSet;
} catch(err) {
	throw Error(err);
}

/* * const replaceQuery = '{{REPLACE}}' não precisa ser alterada, serve apena como identificador * */

/* * REPLACE (via http GET) é case insensitive e pode ser enviado em SNAKE_CASE (padrão do banco deve ser SNAKE_CASE) ou camelCase * */

// ---------------------------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------------------------
// Chamada com SEARCHER (apenas para CamelCase)
const searcher = require('@serverRoot/helpers/searcher');
const paginator = require('@serverRoot/helpers/paginator');

try {
	const replaceQuery = '{{REPLACE}}';
	const baseQuery = `
		select top 10
			*
		from
			usuario a (nolock)
			inner join tipo b (nolock)
				on (a.id_tipo = b.id_tipo)
		where
			a.nome like('%jo%')
			${replaceQuery}
	`;

	// Searcher: searchFields deve ser uma array (colunas inválidas para pesquisa geram erro)
	let { recordsets: recordSets, ...resultSet } = await searcher.setSearch(
		req,
		baseQuery,
		replaceQuery
	);

	resultSet.recordset = await paginator.keysToCamelCase(resultSet.recordset);

	return resultSet;
} catch(err) {
	throw Error(err);
}

/* * const replaceQuery = '{{REPLACE}}' não precisa ser alterada, serve apena como identificador * */

/* * REPLACE (via http GET) é case insensitive e pode ser enviado em SNAKE_CASE (padrão do banco deve ser SNAKE_CASE) ou camelCase * */

// ---------------------------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------------------------
// Chamada com SEARCHER, PAGINACAO e ORDENAÇÃO
const searcher = require('@serverRoot/helpers/searcher');
const paginator = require('@serverRoot/helpers/paginator');

try {
	const replaceQuery = '{{REPLACE}}';
	const baseQuery = `
		select top 10
			*
		from
			usuario a (nolock)
			inner join tipo b (nolock)
				on (a.id_tipo = b.id_tipo)
		${replaceQuery}
	`;

	// Searcher: searchFields deve ser uma array (colunas inválidas para pesquisa geram erro)
	let { recordsets: recordSets, ...resultSet } = await searcher.setSearch(
		req,
		baseQuery,
		replaceQuery
	);

	// Ordenador (sort)
	resultSet.recordset = await paginator.setSort(req, resultSet.recordset, true);
	// Paginador (page)
	resultSet = await paginator.setPage(req, resultSet, resultSet.rowsAffected[0]);

	return resultSet;
} catch(err) {
	throw Error(err);
}

/* * const replaceQuery = '{{REPLACE}}' não precisa ser alterada, serve apena como identificador * */

/* * REPLACE (via http GET) é case insensitive e pode ser enviado em SNAKE_CASE (padrão do banco deve ser SNAKE_CASE) ou camelCase * */

/* * Apenas UM toCamelCase é necessário em todas as chamadas * */

/*
   * se toCamelCase = true no setSort, utilizar camelCase exato (case sensitive) para identificar as chaves de sort no Json *
   * se toCamelCase = false no setSort, utilizar nome da coluna exato no banco de dados (case sensitive) para identificar as chaves de sort no Json *
*/

// ---------------------------------------------------------------------------------------------------------
