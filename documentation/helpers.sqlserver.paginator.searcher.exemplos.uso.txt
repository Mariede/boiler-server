LIB db.js (SQL Server) + paginator.js + searcher.js
===================================================

Conexão e execução de queries no MS SQL Server através do pacote NODE mssql


// ---------------------------------------------------------------------------------------------------------
// Recordsets - padrão de retorno:

Não paginado (Lib MSSQL / Searcher):
{
	"recordset": [],
	"output": {},
	"rowsAffected": [
		0
	]
}

Paginado (default):
{
	"pageDetails": {
		"currentPage": 1,
		"itemsPerPage": 10,
		"itemsFrom": 0,
		"itemsTo": 0,
		"itemsCount": 0,
		"totalPages": 0
	},
	"recordset": [],
	"output": {},
	"rowsAffected": [
		0
	]
}
// ---------------------------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------------------------
// Estrutura básica queries (parâmetros de entrada)

query = {
	formato: 1, // 1: Query String, 2: Stored Procedure
	dados: {
		input: [
			['id', 'int', 1],
			['nome', 'varchar(200)', '%Nome Exemplo 1%']
		],
		output: [
			['QTD_RET', 'int']
		],
		executar: `
			SELECT * FROM TABELA T (NOLOCK) WHERE T.ID_TABELA=@id OR T.NOME LIKE(@nome);
			SET @QTD_RET = SCOPE_IDENTITY();
		`
	}
}

query = {
	formato: 2, // 1: Query String, 2: Stored Procedure
	dados: {
		input: [
			['id', 'int', 1],
			['nome', 'varchar(200)', 'Nome Exemplo 2']
		],
		output: [
			['QTD_RET', 'int']
		],
		executar: 'USUARIO_CONSULTAR'
	}
}

/* * input pode utilizar também um formato de chamada com apenas dois parâmetros de entrada, omitindo o tipo do dado * */

// ---------------------------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------------------------
// Parâmetros de entrada (exemplos)

let query = {
		formato: 1,
		dados: {
			input: [
				['nome', 'varchar(200)', 'Joaquim Santos'],
				['senha', 'varchar(20)', 'SENH@TESTE123'],
				['ativo', 'bit', 1],
				['nomeCheck', '%Jo%']
			],
			output: [
				['INSERTED_ID', 'int']
			],
			executar: `
				SET NOCOUNT OFF;
				DECLARE
					@INCR int; -- variavel interna
				SET
					@INCR = (
						SELECT TOP 1
							ID_USUARIO
						FROM
							USUARIO U (NOLOCK)
						WHERE
							U.NOME LIKE(@nomeCheck) -- variavel input externa
						ORDER BY
							ID_USUARIO DESC
					);
				INSERT INTO USUARIO (
					NOME
					,SENHA
					,ATIVO
				) VALUES (
					@nome + ' ' + CAST(@INCR AS varchar) -- variavel input externa + interna
					,@senha -- variavel input externa
					,@ativo -- variavel input externa
				);
				SET
					@INSERTED_ID = SCOPE_IDENTITY(); -- variavel output
				SELECT TOP 2
					NOME
				FROM
					USUARIO U (NOLOCK)
				WHERE
					U.NOME LIKE(@nomeCheck) -- variavel input externa
				ORDER BY
					ID_USUARIO DESC;
				SELECT TOP 3
					*
				FROM
					USUARIO U (NOLOCK)
				WHERE
					U.NOME LIKE(@nomeCheck) -- variavel input externa
				ORDER BY
					ID_USUARIO DESC;
			`
		}
	},
	otherQuery = {
		formato: 2,
		dados: {
			input: [
				['idUsuario', 'int', 1],
				['nome', 'varchar(200)', 'jo']
			],
			output: [
				['QTD_RET', 'int']
			],
			executar: 'USUARIO_CONSULTAR'
		}
	},
	anotherQuery = {
		formato: 1,
		dados: {
			input: [
				['nome', '%jo%']
			],
			executar: 'SELECT ID_USUARIO, NOME, SENHA, ATIVO FROM USUARIO (NOLOCK) WHERE NOME LIKE(@nome)'
		}
	};
// ---------------------------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------------------------
// Chamadas nos métodos (exemplos)

// Execute (async await)
const dbCon = require('@serverRoot/helpers/db');

const query = {
	formato: 1,
	dados: {
		input: [
			['nome', '%jo%']
		],
		executar: 'SELECT ID_USUARIO, NOME, SENHA, ATIVO FROM USUARIO (NOLOCK) WHERE NOME LIKE(@nome)'
	}
};

let transaction = await dbCon.msSqlServer.sqlOpenCon(),
	{ recordsets: recordSets, ...resultSet } = await dbCon.msSqlServer.sqlExecute(transaction, query); // Executa query ou queries

await dbCon.msSqlServer.sqlCloseCon(transaction);

return resultSet;
// ---------------------------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------------------------
// ou com o método agrupador ExecuteAll (async await)
const dbCon = require('@serverRoot/helpers/db');

const query = {
	formato: 1,
	dados: {
		input: [
			['nome', '%jo%']
		],
		executar: 'SELECT ID_USUARIO, NOME, SENHA, ATIVO FROM USUARIO (NOLOCK) WHERE NOME LIKE(@nome)'
	}
};

// Executa query ou queries
let { recordsets: recordSets, ...resultSet } = await dbCon.msSqlServer.sqlExecuteAll(query);

return resultSet;
// ---------------------------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------------------------
// Chamada com PAGINAÇÃO
const dbCon = require('@serverRoot/helpers/db');
const paginator = require('@serverRoot/helpers/paginator');

const query = {
	formato: 1,
	dados: {
		input: [
			['nome', '%jo%']
		],
		executar: 'SELECT ID_USUARIO, NOME, SENHA, ATIVO FROM USUARIO (NOLOCK) WHERE NOME LIKE(@nome)'
	}
};

// Executa query ou queries
let { recordsets: recordSets, ...resultSet } = await dbCon.msSqlServer.sqlExecuteAll(query);

// Paginador (page)
resultSet = await paginator.setPage(req, resultSet, resultSet.rowsAffected[0], true);

return resultSet;
// ---------------------------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------------------------
// Chamada com PAGINAÇÃO e ORDENAÇÃO
const dbCon = require('@serverRoot/helpers/db');
const paginator = require('@serverRoot/helpers/paginator');

const query = {
	formato: 1,
	dados: {
		input: [
			['nome', '%jo%']
		],
		executar: 'SELECT ID_USUARIO, NOME, SENHA, ATIVO FROM USUARIO (NOLOCK) WHERE NOME LIKE(@nome)'
	}
};

// Executa query ou queries
let { recordsets: recordSets, ...resultSet } = await dbCon.msSqlServer.sqlExecuteAll(query);

// Ordenador (sort)
resultSet.recordset = await paginator.setSort(req, resultSet.recordset, true);
// Paginador (page)
resultSet = await paginator.setPage(req, resultSet, resultSet.rowsAffected[0]);

return resultSet;

/*
	* Apenas UM toCamelCase é necessário em todas as chamadas
		=> parâmetro toCamelCase existe em ambos os métodos setSort e em setPage da lib paginator

	* se toCamelCase = true no setSort:
		=> utilizar camelCase exato (case sensitive) para identificar as chaves de sort no Json
		=> é o caso do exemplo

	* se toCamelCase = false no setSort:
		=> utilizar nome da coluna exato no banco de dados (case sensitive) para identificar as chaves de sort no Json
*/

// ---------------------------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------------------------
// Chamada com SEARCHER
const searcher = require('@serverRoot/helpers/searcher');

const replaceQuery = '{{REPLACE}}';
const baseQuery = `
	select top 10
		*
	from
		usuario a (nolock)
		inner join tipo b (nolock)
			on (a.id_tipo = b.id_tipo)
	where
		a.nome like('%jo%')
		${replaceQuery}
`;

// Searcher: searchFields deve ser uma array (colunas inválidas para pesquisa geram erro)
let { recordsets: recordSets, ...resultSet } = await searcher.setSearch(
	req,
	baseQuery,
	replaceQuery
);

return resultSet;


/* * const replaceQuery = '{{REPLACE}}' não precisa ser alterada, serve apena como identificador * */

/*
	* REPLACE (via http GET) é case insensitive e pode ser enviado em:
		=> SNAKE_CASE (padrão do banco deve ser SNAKE_CASE)
		=> camelCase
*/

// ---------------------------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------------------------
// Chamada com SEARCHER (json de retorno em camelCase)
const searcher = require('@serverRoot/helpers/searcher');
const paginator = require('@serverRoot/helpers/paginator');

const replaceQuery = '{{REPLACE}}';
const baseQuery = `
	select top 10
		*
	from
		usuario a (nolock)
		inner join tipo b (nolock)
			on (a.id_tipo = b.id_tipo)
	where
		a.nome like('%jo%')
		${replaceQuery}
`;

// Searcher: searchFields deve ser uma array (colunas inválidas para pesquisa geram erro)
let { recordsets: recordSets, ...resultSet } = await searcher.setSearch(
	req,
	baseQuery,
	replaceQuery
);

resultSet.recordset = await paginator.keysToCamelCase(resultSet.recordset);

return resultSet;


/* * const replaceQuery = '{{REPLACE}}' não precisa ser alterada, serve apena como identificador * */

/*
	* REPLACE (via http GET) é case insensitive e pode ser enviado em:
		=> SNAKE_CASE (padrão do banco deve ser SNAKE_CASE)
		=> camelCase
*/

// ---------------------------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------------------------
// Chamada com SEARCHER, PAGINACAO e ORDENAÇÃO
const searcher = require('@serverRoot/helpers/searcher');
const paginator = require('@serverRoot/helpers/paginator');

const replaceQuery = '{{REPLACE}}';
const baseQuery = `
	select top 10
		*
	from
		usuario a (nolock)
		inner join tipo b (nolock)
			on (a.id_tipo = b.id_tipo)
	${replaceQuery}
`;

// Searcher: searchFields deve ser uma array (colunas inválidas para pesquisa geram erro)
let { recordsets: recordSets, ...resultSet } = await searcher.setSearch(
	req,
	baseQuery,
	replaceQuery
);

// Ordenador (sort)
resultSet.recordset = await paginator.setSort(req, resultSet.recordset, true);
// Paginador (page)
resultSet = await paginator.setPage(req, resultSet, resultSet.rowsAffected[0]);

return resultSet;


/* * const replaceQuery = '{{REPLACE}}' não precisa ser alterada, serve apena como identificador * */

/*
	* REPLACE (via http GET) é case insensitive e pode ser enviado em:
		=> SNAKE_CASE (padrão do banco deve ser SNAKE_CASE)
		=> camelCase
*/

/*
	* Apenas UM toCamelCase é necessário em todas as chamadas
		=> parâmetro toCamelCase existe em ambos os métodos setSort e em setPage da lib paginator

	* se toCamelCase = true no setSort:
		=> utilizar camelCase exato (case sensitive) para identificar as chaves de sort no Json
		=> é o caso do exemplo

	* se toCamelCase = false no setSort:
		=> utilizar nome da coluna exato no banco de dados (case sensitive) para identificar as chaves de sort no Json
*/

// ---------------------------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------------------------
// usuario.consultarTodos (Exemplo de codificação no boiler)

const dbCon = require('@serverRoot/helpers/db');
const paginator = require('@serverRoot/helpers/paginator');

const consultarTodos = async (req, res) => {
	const query = {
		formato: 1,
		dados: {
			executar: `
				SELECT
					A.ID_USUARIO
					,A.ID_TIPO
					,A.NOME
					,A.EMAIL
					,A.SENHA
					,A.SALT
					,A.ATIVO
					,B.TIPO
				FROM
					USUARIO A (NOLOCK)
					INNER JOIN TIPO B (NOLOCK)
						ON (A.ID_TIPO = B.ID_TIPO);
			`
		}
	};

	let { recordsets: recordSets, ...resultSet } = await dbCon.msSqlServer.sqlExecuteAll(query);

	resultSet.recordset = await paginator.setSort(req, resultSet.recordset, true); // Ordenador
	resultSet = await paginator.setPage(req, resultSet, resultSet.rowsAffected[0]); // Paginador

	return resultSet;
};
// ---------------------------------------------------------------------------------------------------------

// ---------------------------------------------------------------------------------------------------------
// usuario.consultar (Exemplo de codificação no boiler)

const dbCon = require('@serverRoot/helpers/db');
const paginator = require('@serverRoot/helpers/paginator');
const validator = require('@serverRoot/helpers/validator');
const errWrapper = require('@serverRoot/helpers/errWrapper');

const consultar = async (req, res) => {
	const idUsuario = req.params.id;

	let checkedResultSet = {};

	if (validator.isInteger(idUsuario, false)) {
		const query = {
			formato: 1,
			dados: {
				input: [
					['idUsuario', 'int', idUsuario]
				],
				executar: `
					SELECT
						A.ID_USUARIO
						,A.ID_TIPO
						,A.NOME
						,A.EMAIL
						,A.SENHA
						,A.SALT
						,A.ATIVO
						,B.TIPO
					FROM
						USUARIO A (NOLOCK)
						INNER JOIN TIPO B (NOLOCK)
							ON (A.ID_TIPO = B.ID_TIPO)
					WHERE
						A.ID_USUARIO = @idUsuario;
				`
			}
		};

		let { recordsets: recordSets, ...resultSet } = await dbCon.msSqlServer.sqlExecuteAll(query);

		resultSet.recordset = await paginator.keysToCamelCase(resultSet.recordset); // Chaves para camelCase

		checkedResultSet = resultSet;
	} else {
		errWrapper.throwThis('AUTH', 400, 'ID do usuário deve ser numérico...');
	}

	return checkedResultSet;
};
// ---------------------------------------------------------------------------------------------------------
